<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> [AI810 Blog Post (20255036)] Generative Models for Inorganic Crystals &amp; Metal-Orgranic Frameworks | Nayoung Kim </title> <meta name="author" content="Nayoung Kim"> <meta name="description" content="In this blog post, we review two recent works on generative models for crystals. One is SymmCD, which generates inorganic crystals by leveraging their special symmetry properties. The other is MOFDiff, which generates metal-organic frameworks by (MOFs) by exploiting their modular nature."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8D%A9&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nayoung10.github.io/blog/2025/distill/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "[AI810 Blog Post (20255036)] Generative Models for Inorganic Crystals & Metal-Orgranic Frameworks",
            "description": "In this blog post, we review two recent works on generative models for crystals. One is SymmCD, which generates inorganic crystals by leveraging their special symmetry properties. The other is MOFDiff, which generates metal-organic frameworks by (MOFs) by exploiting their modular nature.",
            "published": "June 01, 2025",
            "authors": [
              
              {
                "author": "Nayoung Kim",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "KAIST",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Nayoung</span> Kim </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item"> <a class="nav-link" href="/assets/pdf/cv.pdf" target="_blank" rel="noopener noreferrer">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>[AI810 Blog Post (20255036)] Generative Models for Inorganic Crystals &amp; Metal-Orgranic Frameworks</h1> <p>In this blog post, we review two recent works on generative models for crystals. One is SymmCD, which generates inorganic crystals by leveraging their special symmetry properties. The other is MOFDiff, which generates metal-organic frameworks by (MOFs) by exploiting their modular nature.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#motivation">Motivation</a> </div> <ul> <li> <a href="#two-types-of-crystals-two-types-of-challenges">Two Types of Crystals, Two Types of Challenges</a> </li> </ul> <div> <a href="#symmcd-symmetry-preserving-crystal-generation-with-diffusion-models">SymmCD: Symmetry-Preserving Crystal Generation with Diffusion Models</a> </div> <ul> <li> <a href="#preliminary-representing-crystals">Preliminary: Representing Crystals</a> </li> <li> <a href="#asymmetric-unit-and-site-symmetries">Asymmetric Unit and Site Symmetries</a> </li> <li> <a href="#symmcd-pre-processing-training-and-sampling">SymmCD: Pre-processing, Training, and Sampling</a> </li> <li> <a href="#experimental-results-symmcd-generates-diverse-and-novel-crystals">Experimental Results: SymmCD Generates Diverse and Novel Crystals</a> </li> </ul> <div> <a href="#mofdiff-coarse-grained-diffusion-for-metal-organic-framework-design">MOFDiff: Coarse-grained Diffusion for Metal-Organic Framework Design</a> </div> <ul> <li> <a href="#preliminary-coarse-grained-representation-for-mofs">Preliminary: Coarse-grained representation for MOFs</a> </li> <li> <a href="#learning-building-block-representations">Learning Building Block Representations</a> </li> <li> <a href="#training-mofdiff">Training MOFDiff</a> </li> <li> <a href="#sampling-pipeline-for-mofdiff">Sampling Pipeline for MOFDiff</a> </li> <li> <a href="#evaluation-results-mofdiff-generates-high-quality-mofs">Evaluation Results: MOFDiff generates high-quality MOFs</a> </li> </ul> </nav> </d-contents> <div class="preamble"> $$ \newcommand{\cM}{\mathcal{M}} \newcommand{\cA}{\mathcal{A}} \newcommand{\bA}{\mathbf{A}} \newcommand{\bX}{\mathbf{X}} \newcommand{\bL}{\mathbf{L}} \newcommand{\bS}{\mathbf{S}} \newcommand{\bbR}{\mathbb{R}} $$ </div> <h2 id="motivation">Motivation</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/examples-480.webp 480w,/assets/img/2025-04-28-_nayoung/examples-800.webp 800w,/assets/img/2025-04-28-_nayoung/examples-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/examples.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 1. Examples of crystals.</figcaption> </figure> <p>Materials span a wide range of structural and chemical complexities, from amorphous polymers to highly ordered solids. Among them, <strong>crystals</strong> refer to materials with a <em>regular</em>, <em>repeating</em> arrangement of atoms or molecules. Many everyday materials are crystalline (Figure 1): <em>diamond</em>, known for its extreme hardness; <em>quartz</em>, used in electronics; and <em>table salt</em>, essential in daily life. Designing new crystalline materials with desirable properties is at the heart of breakthroughs in energy, electronics, and environmental sustainability.</p> <p>In recent years, <strong>generative models</strong> have gained attention as powerful tools for automating the design of novel crystal structures. Most existing work focuses on <strong>inorganic crystals</strong><d-cite key="jiao2024crystal"></d-cite><d-cite key="millerflowmm"></d-cite><d-cite key="linequivariant"></d-cite>, which include materials like semiconductors, superconductors, and catalysts. More recently, some attention has turned to <strong>metal-organic frameworks (MOFs)</strong><d-cite key="fu2023mofdiff"></d-cite>, a crystalline materials composed of <strong>metal clusters</strong> and <strong>organic linkers</strong>. Their porous structures and high tunability make them promising candidates for gas storage<d-cite key="li2018recent"></d-cite><d-cite key="qian2020mof"></d-cite>, catalysis,<d-cite key="lee2009metal"></d-cite> and drug delivery<d-cite key="horcajada2012metal"></d-cite>.</p> <h3 id="two-types-of-crystals-two-types-of-challenges">Two Types of Crystals, Two Types of Challenges</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/inorganic_vs_mof-480.webp 480w,/assets/img/2025-04-28-_nayoung/inorganic_vs_mof-800.webp 800w,/assets/img/2025-04-28-_nayoung/inorganic_vs_mof-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/inorganic_vs_mof.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 2. Examples of inorganic crystals and metal-organic frameworks.</figcaption> </figure> <p>While both inorganic crystals and MOFs are crystalline materials, their fundamental differences introduce distinct challenges for generative modeling (Figure 2):</p> <ul> <li> <strong>Inorganic crystals</strong> typically contain fewer atoms per structure and exhibit high degrees of <strong>symmetry</strong>. However, they lack natural subunits, making them difficult to decompose or simplify for modeling.</li> <li> <strong>MOFs</strong>, in contrast, often consist of hundreds to thousands of atoms per structure. Fortunately, their <strong>modular nature</strong> allows them to be decomposed into well-defined building blocks: metal nodes and organic linkers.</li> </ul> <table> <thead> <tr> <th> </th> <th><strong>Inorganic</strong></th> <th><strong>MOF</strong></th> </tr> </thead> <tbody> <tr> <td>Size</td> <td>~10-50 atoms/structure</td> <td>~50-2000 atoms/structure</td> </tr> <tr> <td>Key structural trait</td> <td>Symmetry-rich</td> <td>Modular</td> </tr> <tr> <td>Generation challenge</td> <td>Capturing symmetry</td> <td>Scaling to large structures</td> </tr> </tbody> </table> <p>In this blogpost, we explore two recent generative models that address these distinct challenges:</p> <ul> <li> <strong>SymmCD (ICLR 2025)</strong><d-cite key="levy2025symmcd"></d-cite> targets <em>inorganic crystals</em> using a diffusion model that explicitly incorporates <em>symmetry</em>. By learning to generate only the <em>asymmetric unit</em> and expanding it via symmetry operations, it ensures validity and efficiency in generation.</li> <li> <strong>MOFDiff (ICLR 2024)</strong><d-cite key="fu2023mofdiff"></d-cite> focuses on <em>MOFs</em> by leveraging their modularity through a <em>coarse-grained representation</em>. By learning to generate the coarse-grained representation, MOFDiff succesffully generates large and complex MOF structures.</li> </ul> <p>The following table provides a quick <strong>summary</strong> of the two works:</p> <table> <thead> <tr> <th> </th> <th><strong>SymmCD</strong></th> <th><strong>MOFDiff</strong></th> </tr> </thead> <tbody> <tr> <td>Target material</td> <td>Inorganic crystals</td> <td>Metal-organic frameworks</td> </tr> <tr> <td>Dataset</td> <td>Materials Project<d-cite key="Jain2013"></d-cite> </td> <td>BW-DB<d-cite key="boyd2019data"></d-cite> </td> </tr> <tr> <td>Key idea</td> <td>Generate asymmetric unit and reconstruct full structure using symmetry</td> <td>Generate coarse-grained MOF structure based the modular nature of MOFs</td> </tr> <tr> <td>Method</td> <td>Diffusion</td> <td>Diffusion</td> </tr> <tr> <td>Publication</td> <td>ICLR 2025</td> <td>ICLR 2024</td> </tr> </tbody> </table> <h2 id="symmcd-symmetry-preserving-crystal-generation-with-diffusion-models">SymmCD: Symmetry-Preserving Crystal Generation with Diffusion Models</h2> <h3 id="preliminary-representing-crystals">Preliminary: Representing Crystals</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/unit_cell-480.webp 480w,/assets/img/2025-04-28-_nayoung/unit_cell-800.webp 800w,/assets/img/2025-04-28-_nayoung/unit_cell-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/unit_cell.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 3. The unit cell representation of a crystal. The ideal, infinite crystal structure can be recovered by replicating the cell along the three lattice vectors.</figcaption> </figure> <p>To represent a 3D structure of a <strong>molecule</strong> with \(N\) atoms, we typically specify two components:</p> <ol> <li>The atom types \(\bA=(a_1, \dots, a_N) \in \cA^N\), where each \(\cA\) is the set of possible elements,</li> <li>The 3D coordinates of those atoms, \(\bX=(x_1, \dots, x_N) \in \bbR^{N \times 3}\).</li> </ol> <p><strong>Crystals</strong> are similar, but with one key addition: the <strong>lattice</strong>. The lattice is defined by three lattice vectors \(\mathbf{L}=(l_1, l_2, l_3) \in \bbR^{N \times 3}\) which describe how the unit cell repeasts in space. This compact <strong>unit cell representation</strong> \(\cM = (\bA, \bX, \bL)\) contains all the information needed to define a crystal. By translating the atoms along the lattice vectors \(l_1, l_2, l_3\), we can reconstruct the full (theorectically infinite) periodic structure of the crystal (Figure 3).</p> <h3 id="asymmetric-unit-and-site-symmetries">Asymmetric Unit and Site Symmetries</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/asymmetric_unit-480.webp 480w,/assets/img/2025-04-28-_nayoung/asymmetric_unit-800.webp 800w,/assets/img/2025-04-28-_nayoung/asymmetric_unit-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/asymmetric_unit.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 4. (left) An asymmetric unit can be unfolded using symmetry operations to reconstruct the full unit cell. (right) SymmCD generates the asymmetric unit, which contains the atom types, coordinates, lattice, and site symmetries.</figcaption> </figure> <p>While the unit cell representation \(\cM = (\bA, \bX, \bL)\) compactly represents a crystal, <strong>SymmCD</strong> uses an even smaller representation: the <strong>asymmetric unit</strong>. The asymmetric unit can be combined with crystal symmetry operations to reconstruct the full unit cell (Figure 4, <em>left</em>).</p> <p>A useful analogy for understanding the asymmetric unit is <em>cutting a paper snowflake</em><d-cite key="fredericks2021pyxtal"></d-cite>: the folded paper represents the asymmetrc unit, and unfolding aplies the symmetry to create the full pattern of the paper snowflake.</p> <p>But here’s the subtle part: <em>where</em> you make the cut affects how many times it appears in the final pattern. For instance, a cut at the center of the folded paper is repeated six times, while a cut at an edge appears three times. In crystallography, this concept is captured by the <strong>site symmetry</strong> – it tells you <em>how</em> to replicate an atom based on its position on the asymmetric unit.</p> <p>SymmCD leverages these two simple concepts for inorganic crystal generation. Rather than generating the full crystal, it generates just the asymmetric unit, which contains the atom types, coordinates, lattice, and site symmetries (Figure 4, <em>right</em>). This simplifies the generation process while guaranteeing that the resulting structures are symmetric.</p> <p>Mathematically, we represent an asymmetric unit with:</p> <ul> <li>Atom types \(\bA' = (a_1', \dots, a_M') \in \cA^M\),</li> <li>3D coordinates \(\bX=(x_1', \dots, x_M') \in \bbR^{M \times 3}\),</li> <li>Asymmetric lattice \(\mathbf{k} \in \mathbb{R}^6\) (see the paper<d-cite key="levy2025symmcd"></d-cite> for details), and</li> <li>Site symmetries \(\bS = (S_{x_1'}, \dots, S_{x_M'}) \in \mathcal{P}^M\), where \(\mathcal{P}\) denotes the set of all possible site symmetries.</li> </ul> <p>Note that \(M \leq N\), since the asymmetric unit contains only a subset of the atoms in the full unit cell.</p> <h3 id="symmcd-pre-processing-training-and-sampling">SymmCD: Pre-processing, Training, and Sampling</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/symmcd_pipeline-480.webp 480w,/assets/img/2025-04-28-_nayoung/symmcd_pipeline-800.webp 800w,/assets/img/2025-04-28-_nayoung/symmcd_pipeline-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/symmcd_pipeline.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 5. The full pipeline of SymmCD, including pre-processing, training, sampling, and post-processing.</figcaption> </figure> <h4 id="pre-processing-extracting-the-asymmetric-unit">Pre-processing: Extracting the Asymmetric Unit</h4> <p>Recall that the core idea of SymmCD is to model the <strong>asymmetric unit</strong> rather than the entire unit cell. But <em>how</em> do we extract the asymmetric unit from a given crystal?</p> <p>Crucially, <em>all</em> crystals belong to one of just 230 space groups, each defining a unique set of symmetry operations. Given a crystal in unit cell form, \(\cM = (\bA, \bX, \bL)\), we first determine its space group \(G\) – this can be done using tools such as spglib<d-cite key="spglib"></d-cite>. The space group encodes the symmetries present in the crystal, which in turn define its asymmetric unit.</p> <p>Using this information, we convert the dataset from unit cell representation to asymmetric unit cell representation as follows: \(\begin{equation} \mathcal{D} = \{ (\bA, \bX, \bL) \} \Rightarrow{} \mathcal{D} = \{ (G, \mathbf{k}, \bA', \bX', \bS) \}. \end{equation}\)</p> <h4 id="training-the-model">Training the Model</h4> <p>SymmCD models the joint distribution over asymmetric unit components and the space group as: \(\begin{equation} p_{\theta}(G, \mathbf{k}, \bA', \bX', \bS)=p_{\theta}(\mathbf{k}, \bA', \bX', \bS \vert G)p(G). \end{equation}\)</p> <p>That is, once a space group \(G\) is specified (or sampled), the model generates a compatible asymmetric unit \((\mathbf{k}, \bA', \bX', \bS)\). To achieve this, SymmCD trains an E(3)-equivariant graph neural network (GNN), where the atom types and site symmetries \(\bA', \bS\) are learned with discrete diffusion and the lattice \(\mathbf{k}, \bX'\) are learned with continuous diffusion.</p> <h4 id="sampling-and-post-processing">Sampling and Post-processing</h4> <p>Generating inorganic crystal structures with SymmCD involves three main steps:</p> <ol> <li>Select a space group \(G\) – either randomly or based on desired properties.</li> <li>Sample asymmetric unit \((\mathbf{k}, \bA', \bX', \bS)\) using the trained diffusion model.</li> <li>Project the generated atoms into valid <strong>Wyckoff positions</strong> based on their site symmetries.</li> </ol> <p>Why is this projection step necessary? Recall the paper snowflake analogy: a cut made at the center is repeated more times than one near the edge. In crystals, certain regions of the asymmetric unit permit only specific site symmetries. If a generated atom-site symmetry pair is invalid, its position must be projected a location compatible with the symmetry constraints.</p> <p>Finally, the full unit cell \(\cM = (\bA, \bX, \bL)\) is reconstructed by applying the symmetry operations associated with each atom’s site symmetry. By generating only the asymmetric unit, SymmCD reduces computational complexity while ensuring symmetric outputs.</p> <h3 id="experimental-results-symmcd-generates-diverse-and-novel-crystals">Experimental Results: SymmCD Generates Diverse and Novel Crystals</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/symmcd_results-480.webp 480w,/assets/img/2025-04-28-_nayoung/symmcd_results-800.webp 800w,/assets/img/2025-04-28-_nayoung/symmcd_results-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/symmcd_results.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 6. Comparison of crystals generated by SymmCD and baseline models. (left) Distribution of space group symmetries across generated samples. (middle) Number of novel (unseen) structures produced by each model. (right) Example crystal generated by SymmCD with space group Pmmm.</figcaption> </figure> <p>In the experiments, 10,000 crystals are generated from each model and evaluated based on the distribution of <strong>space group symmetries</strong> and <strong>novelty</strong>.</p> <p>Both SymmCD and DiffCSP++<d-cite key="jiaospace"></d-cite> generate crystals spanning a wide range of space group symmetries, demonstrating their capacity to model diverse crystal types (Figure 6, <em>left</em>). However, SymmCD achieves higher novelty, since it learns to generate asymmetric units from scratch, whereas DiffCSP++ relies on refining known templates (Figure 6, <em>middle</em>). Figure 6, <em>right</em> shows an example crystal generated by SymmCD with space group Pmmm, demonstrating the model’s ability produce valid and symmetric structures.</p> <h2 id="mofdiff-coarse-grained-diffusion-for-metal-organic-framework-design">MOFDiff: Coarse-grained Diffusion for Metal-Organic Framework Design</h2> <h3 id="preliminary-coarse-grained-representation-for-mofs">Preliminary: Coarse-grained Representation for MOFs</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/mof_representation-480.webp 480w,/assets/img/2025-04-28-_nayoung/mof_representation-800.webp 800w,/assets/img/2025-04-28-_nayoung/mof_representation-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/mof_representation.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 7. Decomposing a MOF into its building blocks. (a) An example MOF unit cell. (b) Metal node and organic linkers visualized one at a time for visual clarity. (c) All four building blocks in the example. The blue dumbbell-shaped building block is metal, while others are organic.</figcaption> </figure> <p>Metal–Organic Frameworks (MOFs) are one of the structurally complex materials known. Compared to inorganic crystals, they are much larger, often containing hundreds to thousands of atoms per unit cell. This scale makes atom-level generative modeling both inefficient and prone to poor performance.</p> <p>Fortunately, MOFs come with a built-in advantage: <strong>modularity</strong>. Each MOF is composed of building blocks called metal clusters and organic linkers (Figure 7). Therefore, instead of representing MOFs as full atomic structures \((\bA, \bX, \bL)\), MOFDiff uses a simplified, coarse-grained representation \(\begin{equation} \cM^C = (\bA^C, \bX^C, \bL) \end{equation}\) where:</p> <ul> <li>\(\bA^C = (a_1^C, \dots, a_K^C) \in \mathbb{B}^{K}\) are the building block types (e.g., a metal node or linker),</li> <li>\(\bX^C = (x_1^C, \dots x_K^C) \in \bbR^{K \times 3}\) are their 3D Cartesian coordinates, and</li> <li>\(\bL\) is the lattice that defines periodicity (same as unit cell representation).</li> </ul> <p>The core idea behind MOFDiff is to learn this coarse-grained representation instead of modeling the full atomic structure. Since \(K \ll N\), this representation is much more efficient to model.</p> <h3 id="learning-building-block-representations">Learning Building Block Representations</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/contrastive_learning-480.webp 480w,/assets/img/2025-04-28-_nayoung/contrastive_learning-800.webp 800w,/assets/img/2025-04-28-_nayoung/contrastive_learning-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/contrastive_learning.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 8. Schematic for learning building block representations. A contrastive loss is used to train the graph neural network encoder so that topologically same building blocks are mapped to nearby points in the embedding space.</figcaption> </figure> <p>How do we represent these building blocks effectively?</p> <p>A naive approach might be to extract all building blocks from the training dataset, assign each a one-hot encoding, then train a diffusion model: discrete diffusion for the building block types \(\bA^C\), and continuous diffusions for their positions \(\bX^C\) and lattice \(\bL\).</p> <p>However, the training dataset contains around 2 million of building blocks, which makes one-hot encoding extremely sparse and hard to learn. Also, many of these building blocks are topologically identical – they have the same atom and bond structure (i.e., same 2D graph), differing only slightly in 3D geometry, making this representation very inefficient.</p> <p>To overcome this, MOFDiff learns a <strong>dense</strong>, <strong>continuous</strong> embedding \(\bA^C\) for each building block that captures topological similarity. It does this by training a <strong>SE(3)-invariant graph neural network</strong> takes as input the \(i\) building block (i.e., its atom types and coordinates) and outputs a dense embedding \(\mathbf{b}_i \in \bbR^d\) corresponding to that building block.</p> <p>To ensure that the learned embeddings group similar building blocks together, MOFDiff uses a <strong>contrastive learning objective</strong> (Figure 8). Specifically, it first computes ECFP4, a molecular fingerprint which encodes topological information, then trains the models with a contrastive loss that brings structures with same ECFP4 close together in the embedding space.</p> <p>The contrastive loss is defined as: \(\begin{equation} \mathcal{L}_C = - \log \sum_{i \in \mathbf{B}} \left( \frac{\sum_{j \in \mathbf{B}_i^{+}} \exp(s_{i,j} / \tau)}{\sum_{j \in \mathbf{B} \setminus \{i\}} \exp(s_{i,j} / \tau)} \right) \end{equation}\) where</p> <ul> <li>$\mathbf{B}$ is a batch of building blocks,</li> <li>$\mathbf{B}_i^{+} \subseteq \mathbf{B}$ are building blocks with the same ECFP4 fingerprint as $i$,</li> <li>$s_{i,j}$ is the <em>cosine similarity</em> between projected building block embeddings:<br> \(\begin{equation} s_{i,j} = \frac{\mathbf{p}_i^{\top} \mathbf{p}_j}{\|\mathbf{p}_i\| \|\mathbf{p}_j\|}, \quad \mathbf{p}_i = \operatorname{MLP}(\mathbf{b}_i) \end{equation}\)</li> <li>$\tau$ is the temperature.</li> </ul> <p>Once trained, this encoder maps each building block to a dense vector embedding. All MOFs in the dataset can then be transformed into their coarse-grained representation \(\cM = (\bA^C, \bX^C, \bL)\), where \(\bA^C = (\mathbf{b}_1, \dots, \mathbf{b}_K) \in \bbR^{K \times d}\) is the dense embedding. The paper uses \(d=32\), which is much more compact representation than a one-hot encoding over ~2M types of building blocks.</p> <h3 id="training-mofdiff">Training MOFDiff</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/mofdiff_training-480.webp 480w,/assets/img/2025-04-28-_nayoung/mofdiff_training-800.webp 800w,/assets/img/2025-04-28-_nayoung/mofdiff_training-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/mofdiff_training.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 9. Schematic for training MOFDiff. There are three models involved: (1) an MLP model than predicts lattice L and number of building blocks K from latent vector z, (2) a denoising model over the coarse-grained structure, and (3) an encoder than encodes the coarse-grained representation into a latent vector z.</figcaption> </figure> <p>With the coarse-grained representation in place, it’s time to train the generative model (Figure 9).</p> <p>MOFDiff aims to model the full joint distribution over the coarse-grained structure and an additional latent variable \(\mathbf{z}\): \(\begin{equation} p_{\theta}(\bA^C, \bX^C, \bL, K, \mathbf{z}) = p_{\theta}(\bL, K \vert \mathbf{z}) p_{\theta}(\bA^C, \bX^C \vert \bL, K, \mathbf{z}), \end{equation}\) where:</p> <ul> <li>\(\bA^C=(\mathbf{b}_1, \dots, \mathbf{b}_K) \in \bbR^{K \times d}\) and \(\bX^C = (x_1^C, \dots x_K^C) \in \bbR^{K \times 3}\) are the building block types and positions,</li> <li>\(\bL\) is the lattice,</li> <li>\(\mathbf{z}\) is a latent vector used for generating the \(\bL\), \(K\).</li> </ul> <p>MOFDiff factorizes this distribution as: \(\begin{equation} p_{\theta}(\bA^C, \bX^C, \bL, K, \mathbf{z}) = p_{\theta}(\bL, K \vert \mathbf{z}) p_{\theta}(\bA^C, \bX^C \vert \bL, K, \mathbf{z}). \end{equation}\)</p> <p>The first part, \(p_{\theta}(\bL, K \vert \mathbf{z})\) is modeled using an MLP: \(\begin{equation} \hat{\bL}, \hat{K} = \operatorname{MLP}_{\bL, K}(\mathbf{z}), \end{equation}\) while the second part, \(p_{\theta}(\bA^C, \bX^C \vert \bL, K, \mathbf{z})\) is modeled using score-based diffusion, where a periodic graph neural network denoiser \(\operatorname{PGNN}_D\) predicts the noise in the atom types and coordinates as: \(\begin{equation} \mathbf{s}_{\bA^C}, \mathbf{s}_{\bX^C} = \operatorname{PGNN}_D(\tilde{\cM}_t^C, \mathbf{z}). \end{equation}\) Here, \(\tilde{\cM}_t^C=(\bA_t^C, \bX_t^C, \bL)\) is the noised version of the coarse-grained structure at timestep \(t\) and \(\mathbf{z}\) is the latent vector produced with a periodic graph neural network encoder \(\operatorname{PGNN}_E\): $$ \begin{equation} \mathbf{z} = \operatorname{PGNN}_E(\cM^C). \end{equation}</p> <h4 id="objective-function">Objective function</h4> <p>The denoiser \(\operatorname{PGNN}_D(\cM_t^C, z)\) is trained using the standard denoising score objective: \(\begin{equation} \mathcal{L}_{\boldsymbol{A}}=\mathbb{E}_{t, \boldsymbol{M}^C, \boldsymbol{\epsilon}_{\boldsymbol{A}}}\left[\left\|\boldsymbol{\epsilon}_{\boldsymbol{A}}-\boldsymbol{s}_{\boldsymbol{A}_t^C, \mathbf{z}}\right\|^2\right], \quad \mathcal{L}_{\boldsymbol{X}}=\mathbb{E}_{t, \boldsymbol{M}^C, \boldsymbol{\epsilon}_{\boldsymbol{X}}}\left[\sigma_t^2\left\|\boldsymbol{\epsilon}_{\boldsymbol{X}}-\boldsymbol{s}_{\boldsymbol{X}_t^C, \mathbf{z}}\right\|^2\right]. \end{equation}\) \(\operatorname{MLP}_{\bL, K}(\mathbf{z})\) is supervised with the mean squared error and cross-entropy loss: \(\begin{equation} \mathcal{L}_{\boldsymbol{L}, K}=\|\boldsymbol{L}-\hat{\boldsymbol{L}}\|^2+\operatorname{CrossEntropy}(K, \hat{K}). \end{equation}\) Finally, the encoder \(\operatorname{PGNN}_E\) is regularized with a KL divergence \(\mathcal{L}_{\mathrm{KL}}\) to match a standard normal prior.</p> <p>The overall training objective for MOFDiff combines all components as: \(\begin{equation} \mathcal{L}_{\text {MOFDiff }}=\mathcal{L}_{\boldsymbol{A}}+\mathcal{L}_{\boldsymbol{X}}+\mathcal{L}_{\boldsymbol{L}, K}+\beta_{\mathrm{KL}} \mathcal{L}_{\mathrm{KL}}. \end{equation}\) where \(\beta_{\mathrm{KL}}\) is a hyperparameter that controls the strength of KL regularization, set to 0.01.</p> <h3 id="sampling-pipeline-for-mofdiff">Sampling Pipeline for MOFDiff</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/mofdiff_sampling-480.webp 480w,/assets/img/2025-04-28-_nayoung/mofdiff_sampling-800.webp 800w,/assets/img/2025-04-28-_nayoung/mofdiff_sampling-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/mofdiff_sampling.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 10. Post-processing pipeline for MOFDiff. Once we sample a coarse-grained structure, we should (1) decode the building block identities, (2) rotate the building blocks with a self-assembly process, and (2) relax structure with UFF force field.</figcaption> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/self_assembly-480.webp 480w,/assets/img/2025-04-28-_nayoung/self_assembly-800.webp 800w,/assets/img/2025-04-28-_nayoung/self_assembly-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/self_assembly.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 11. The illustration of self-assembly process. The self-assembly processes maximizes the connection between building blocks (connection points are shown in light blue).</figcaption> </figure> <p>Once MOFDiff is trained, we can generate a new MOF structure with the following process:</p> <ol> <li> <strong>Sample</strong> a random latent code \(\mathbf{z} \sim \mathcal{N}(0,I)\).</li> <li> <strong>Predict</strong> the lattice and number of building blocks: \(\begin{equation} \hat{\bL}, \hat{K} = \operatorname{MLP}_{\bL, K}(\mathbf{z}) \end{equation}\)</li> <li> <strong>Run denoising diffusion</strong> with the trained denoiser \(\operatorname{PGNN}_D(\tilde{\cM}_t^C, \mathbf{z})\) to generate the coarse-grained structure \((\bA^C, \bX^C, \bL)\).</li> </ol> <p>At this point, we have a <strong>coarse-grained MOF</strong>. We now need to recover the full atomic structure with fine-grained details. Here’s how (Figure 10):</p> <ol> <li> <strong>Building block decoding</strong>. For each generated embedding \(\bA^C\), we find the building block from the training dataset that has the closest embedding with nearest neighbor search. We then retrieve actual atom types and coordinates of this closest building block.</li> <li> <strong>Self-assembly process</strong>. Since we have only predicted the center of mass of each building block with \(\bX^C\), we now need to know <em>how to rotate them</em>. MOFDiff uses an optimization-based <strong>sef-assembly algorithm</strong> to find the rotation that maximizes the alignment of connection points between the building blocks (Figure 11).</li> <li> <strong>Force field relaxation</strong>. Finally, the assembled structure undergoes relaxation with energy minimization with the UFF force field. This step ensures that we can make a fine-grained refinement to get the final structure.</li> </ol> <h3 id="evaluation-results-mofdiff-generates-high-quality-mofs">Evaluation Results: MOFDiff generates high-quality MOFs</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-04-28-_nayoung/mofdiff_results-480.webp 480w,/assets/img/2025-04-28-_nayoung/mofdiff_results-800.webp 800w,/assets/img/2025-04-28-_nayoung/mofdiff_results-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2025-04-28-_nayoung/mofdiff_results.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 12. Results for MOFDiff. (left) Validity, novelty, and uniqueness (VNU) of generated structures. (middle) CO2 working capacity distribution of MOFDiff and the training dataset. (right) Promising MOFs with high CO2 capacity sampled with MOFDiff.</figcaption> </figure> <h4 id="generating-valid-novel-and-unique-mofs">Generating Valid, Novel, and Unique MOFs</h4> <p>How does MOFDiff perform in practice? To evaluate it, the authors sampled 10,000 MOF structures and assessed them on three key metrics: <strong>validity</strong>, <strong>novelty</strong>, and <strong>uniqueness</strong>.</p> <ul> <li> <strong>Validity</strong>: A structure is considered valid if it passes the validity check with <code class="language-plaintext highlighter-rouge">MOFChecker</code><d-cite key="xin2025mofchecker"></d-cite>, which assesses whether a MOF is chemically and physically valid based on a set of criteria including the presence of at least one metal, carbon, and hydrogen atom; overlapping atoms; and valency.</li> <li> <strong>Novelty</strong>: A structure is novel if it does not exist in the training dataset. This is measured with <code class="language-plaintext highlighter-rouge">MOFid</code><d-cite key="bucior2019identification"></d-cite>, which computes a unique identifier for a MOF based on its building blocks and connectivity.</li> <li> <strong>Uniqueness</strong>: We find the unique structures by filtering out the duplicates from the generated set of structures.</li> </ul> <p>Out of 10,000 generated structures, <strong>3,012 passed the validity check</strong> and <strong>2,998</strong> were <strong>valid</strong>, <strong>novely</strong>, and <strong>unique</strong> (Figure 12, <em>left</em>). That’s nearly 3,000 high-quality MOFs generated from scratch – an impressive result given the structural complexity and the size of MOFs.</p> <h4 id="discovering-high-performing-mofs-for-carbon-capture">Discovering High-performing MOFs for Carbon Capture</h4> <p>Thanks to the latent variable \(\mathbf{z}\), MOFDiff can also be used for property-guided generation.</p> <p>Suppose you want to discover MOFs with high CO2 working capacity – a key metric for carbon capture technology. MOFDiff enables this by learning a simple property predictor \(\begin{equation} \hat{\mathbf{c}} = \operatorname{MLP}_P(\mathbf{z}), \end{equation}\) where \(\mathbf{c}\) is the property of interest (e.g., CO2 capacity). This predictor is trained with the mean squared error loss using known property labels.</p> <p>To sample MOFs with desired properties, we can let MOFDiff generate many latent vectors \(\mathbf{z} \sim \mathcal{N}(0, I)\), compute the CO2 working capacity \(\hat{\mathbf{c}}\) with the trained predictor, and only decode \(\mathbf{z}\)’s with high CO2 working capacity.</p> <p>In experiments, this approach successfully generates MOFs with higher CO2 working capcity than those in the training dataset, demonstrating MOFDiff’s potential for targeted material discovery (Figure 12, <em>middle</em>). We also show some examples of promising candidates generated by MOFDiff in Figure 12, <em>right</em>.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2025-04-28-_nayoung.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Nayoung Kim. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>